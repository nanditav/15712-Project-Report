\section{Introduction}

Speeding up applications using multi-core/many-core archi-
tectures requires that applications be split into threads that
execute concurrently on different cores. The challenge, how-
ever, is in handling how these threads communicate and access
shared data. If programs are not correctly written without
reasoned synchronization using primitives supplied by the ISA
and hardware architecture, it could easily lead to data races
and incorrect results because of non-deterministic interactions
between threads. Mechanisms to ensure the correctness in
such multi-threaded programs include coherence protocols
in caches and hardware-enforced guarantees and primitives
based on consistency models. These mechanisms ensure cor-
rectness but usually come at the cost of performance and are
complex to implement. Synchronization between threads limit
the scalability of an application by becoming serializing bot-
tlenecks.

For example, coherence protocols are used to ensure that any
data updates to shared data are propagated to all threads in the
program. Typically Snoopy or Directory-based protocols are
used to do this. An increase in the threaded-ness of a program
would pressurize the protocol implementation in hardware
leading to an increase in coherence misses in the caches and
as well as overwhelming the interconnect and memory with
messages and data transfers. At some point, any gains from
parallel execution would be lost due to these overheads.
A primary reason for synchronization complexity is the
need to be assured of complete correctness and precision. But
how important is precision in a program? Prior work ~\cite{hogwild}~\cite{Rinard_patternsand}
have shown that there exist classes of applications that can, in
fact, operate in modes of varying imprecision without catas-
trophic crashes. Examples of these applications include big
data analytics, machine learning, augmented reality, image
processing, etc. This leads to the possibility of trading off
correctness for performance. This trade-off has been explored
in the past to implement approximate computation or approx-
imate storage ~\cite{Sampson}.

The paper is organized as follows. Section 2 presents the background and motivation. Section 3 introduces our proposed approximate coherence protocol. Section 4 explains our methodology and 
Section 5 presents the results. Finally, Section 6 outlines our conclusion and future work.

